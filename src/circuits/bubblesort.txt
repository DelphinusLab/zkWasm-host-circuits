use crate::utils::{
    field_to_bn,
    bn_to_field,
};

use crate::circuits::{
    CommonGateConfig,
    Limb, 
};

use crate::circuits::range::{
    RangeCheckConfig,
    RangeCheckChip,
};

use std::ops::{Mul, Div};
use std::marker::PhantomData;
use halo2_proofs::{
    arithmetic::FieldExt,
    circuit::*,
    plonk::*,
    poly::Rotation
};



struct MainConfig{
    nums: [Column<Advice>; 5],

    compareconfig: CommonGateConfig,
    
}

struct CompareChip<F: FieldExt> {
    config: CommonGateConfig,
    _marker: PhantomData<F>,
}

impl<F: FieldExt> CompareChip<F>{
    fn construct(config: CommonGateConfig) -> Self {
        Self {
            config,
            _marker: PhantomData,
        }
    }

    pub fn configure(cs: &mut ConstraintSystem<F>, range_check_config: &RangeCheckConfig) -> CommonGateConfig {
        CommonGateConfig::configure(cs, range_check_config)
    }

    // cond就是 y = 2^x - (b-a) 的第一位数字
    fn compare(
        &self, 
        region: &mut Region<F>,
        rangecheckchip: &mut RangeCheckChip<F>,
        arr: [Limb<F>; 5],
        idx: usize,
    ) -> Result<[Limb<F>; 5], Error>{
        let lhs = arr[idx].clone();
        let rhs = arr[idx+1].clone();
        let x = u32::pow(2,8);
        let y = F::from(x) - (rhs.value - lhs.value);
        // now check first digit of y
        let mut y_bin: Vec<Limb<F>> = vec![];
        self.config.decompose_limb(region, rangecheckchip, &mut 0, y, &mut y_bin, 32)?;  // u32 values
        let cond = y_bin[0];

        // constrain it
        let result_1 = if cond.value == F::one() {lhs.clone()} else {rhs.clone()};

        let l = self.assign_line(region, rangecheckchip, 0,
            [
                Some(lhs.clone()),
                Some(rhs.clone()),
                Some(cond.clone()),
                Some(cond.clone()),
                Some(result_1.clone()),
                None,
            ],
            [None, Some(F::one()), None, None, Some(-F::one()), None, Some(F::one()), Some(-F::one()), None],
            0,
        )?;

        let result_2 = if cond.value == F::zero() {lhs.clone()} else {rhs.clone()};

        let l = self.assign_line(region, rangecheckchip, &mut 0,
            [
                Some(lhs.clone()),
                Some(rhs.clone()),
                Some(cond.clone()),
                Some(cond.clone()),
                Some(result_2.clone()),
                None,
            ],
            [None, Some(F::one()), None, None, Some(-F::one()), None, Some(F::one()), Some(-F::one()), None],
            0,
        )?;
        arr[idx] = result_1;
        arr[idx+1] = result_2;
        Ok(arr)
    }
}

struct MainChip<F: FieldExt>{
    config: MainConfig,
    _marker: PhantomData<F>,
}

impl<F: FieldExt> MainChip<F> {
    fn construct(config: MainConfig) -> Self {
        Self {
            config,
            _marker: PhantomData,
        }
    }

    fn configure(
        meta: &mut ConstraintSystem<F>,
    ) -> MainConfig {
        let compareconfig = CompareChip::configure(meta);
        // create columns
        let a = meta.advice_column();
        let b = meta.advice_column();
        let c = meta.advice_column();
        let d = meta.advice_column();
        let e = meta.advice_column();

        // enable permutation checks for the following columns
        // we use copy_advice to perform such checks
        meta.enable_equality(a);
        meta.enable_equality(b);
        meta.enable_equality(c);
        meta.enable_equality(d);
        meta.enable_equality(e);

        MainConfig {
            nums: [a, b, c, d, e],
            compareconfig,
        }
    }

    fn load_first_row(
        &self, 
        mut layouter: impl Layouter<F>,
        a: F,
        b: F,
        c: F,
        d: F,
        e: F) -> Result<[Limb<F>; 5], Error> {
            layouter.assign_region(||"first row", |mut region| {
                let a_cell = region.assign_advice(
                    ||"a_0",
                    self.config.nums[0],
                    0,
                    || Value::known(a),
                )?;

                let b_cell = region.assign_advice(
                    ||"b_0",
                    self.config.nums[1],
                    0,
                    || Value::known(b),
                )?;

                let c_cell = region.assign_advice(
                    ||"c_0",
                    self.config.nums[2],
                    0,
                    || Value::known(c),
                )?;

                let d_cell = region.assign_advice(
                    ||"d_0",
                    self.config.nums[3],
                    0,
                    || Value::known(d),
                )?;

                let e_cell = region.assign_advice(
                    ||"e_0",
                    self.config.nums[4],
                    0,
                    || Value::known(e),
                )?;

                Ok([Limb {cell: Some(a_cell.unwrap()), value: a},
                    Limb {cell: Some(b_cell.unwrap()), value: b},
                    Limb {cell: Some(c_cell.unwrap()), value: c},
                    Limb {cell: Some(d_cell.unwrap()), value: d},
                    Limb {cell: Some(e_cell.unwrap()), value: e},
                ])
            },)
        }

    fn load_row(
        &self, 
        mut layouter: impl Layouter<F>,
        nums: [&Limb<F>;5],
    ) -> Result<(Limb<F>, Limb<F>, Limb<F>, Limb<F>, Limb<F>), Error> {
        layouter.assign_region(|| "load row", |mut region|Ok({
            nums[0].cell.unwrap().copy_advice(||"copied", &mut region,self.config.nums[0],0,)?;
            nums[1].cell.unwrap().copy_advice(||"copied", &mut region,self.config.nums[1],0,)?;
            nums[2].cell.unwrap().copy_advice(||"copied", &mut region,self.config.nums[2],0,)?;
            nums[3].cell.unwrap().copy_advice(||"copied", &mut region,self.config.nums[3],0,)?;
            nums[4].cell.unwrap().copy_advice(||"copied", &mut region,self.config.nums[4],0,)?;
            
            Ok(nums)
            }),
        )
    }
}

struct BubSortCircuit<F> {
    arr: [F; 5],
}

impl<F: FieldExt> Circuit<F> for BubSortCircuit<F> {
    type Config = MainConfig;
    type FloorPlanner = SimpleFloorPlanner;

    fn without_witnesses(&self) -> Self {
        Self::default()
    }

    fn configure(meta: &mut ConstraintSystem<F>) -> Self::Config {
        MainChip::configure(meta)
    }

    fn synthesize(
        &self,
        config: Self::Config,
        mut layouter: impl Layouter<F>
    ) -> Result<(), Error> {
        let chip = MainChip::construct(config);
        let compchip = CompareChip::construct(config.compareconfig);
        let mut arr = chip.load_first_row(
            layouter.namespace(|| "first row"),
            self.arr[0],
            self.arr[1],
            self.arr[2],
            self.arr[3],
            self.arr[4],
        )?;
        // rows in the table
        for _round in 1..5 {
            for idx in 0..4 {
                layouter.assign_region(
                    || "",
                    |mut region| {
                        let mut arr = compchip.compare(region, arr, idx);
                        arr[0].cell.unwrap().copy_advice(||"copied", &mut region,self.config.nums[0],0,)?;
                        arr[1].cell.unwrap().copy_advice(||"copied", &mut region,self.config.nums[1],0,)?;
                        arr[2].cell.unwrap().copy_advice(||"copied", &mut region,self.config.nums[2],0,)?;
                        arr[3].cell.unwrap().copy_advice(||"copied", &mut region,self.config.nums[3],0,)?;
                        arr[4].cell.unwrap().copy_advice(||"copied", &mut region,self.config.nums[4],0,)?;
                    },
                );
            }
        }

        Ok(())
    }
}


fn main(){
    todo!()
}